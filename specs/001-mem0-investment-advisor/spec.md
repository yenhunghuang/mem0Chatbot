# 功能規格書：個人化投顧助理（Mem0 練習版）

**功能分支**: `001-mem0-investment-advisor`  
**創建日期**: 2025-10-30  
**狀態**: 草稿  
**輸入**: 使用者描述: "個人化投顧助理（Mem0 練習版，無登入流程）"

<!--
  憲法要求：此規格書必須以繁體中文（zh-TW）撰寫
  根據本地化標準原則。所有使用者面向的元素描述
  也必須使用繁體中文。
-->

## 使用者情境與測試 *(必填)*

### 使用者故事 1 - 基礎對話與記憶建立 (優先級: P1)

使用者開啟聊天介面，直接輸入投資相關的偏好資訊（如「我偏好科技股」、「我的風險屬性是中等」），系統能自動擷取並儲存這些資訊到 Mem0 記憶層。

**為何為此優先級**: 這是整個系統的核心功能，必須先建立記憶儲存機制才能進行後續的個人化服務。

**獨立測試**: 可透過輸入任意投資偏好句子並檢查記憶是否正確儲存來完整測試，提供立即可驗證的價值。

**驗收情境**:

1. **Given** 使用者首次進入聊天介面, **When** 輸入「我偏好科技股」, **Then** 系統儲存此偏好到 Mem0 並確認儲存成功
2. **Given** 使用者已開始對話, **When** 輸入「我的風險屬性是中等」, **Then** 系統擷取並儲存風險偏好資訊
3. **Given** 使用者表達投資地區偏好, **When** 輸入「我長期投資台灣市場」, **Then** 系統識別並儲存地區偏好

---

### 使用者故事 2 - 記憶檢索與個人化回應 (優先級: P2)

使用者在後續對話中詢問投資建議時，系統能從 Mem0 檢索先前儲存的偏好資訊，並將相關內容動態加入上下文，提供個人化的投資建議。

**為何為此優先級**: 展示記憶系統的實際應用價值，讓使用者體驗到個人化服務的效果。

**獨立測試**: 可在已建立記憶的基礎上，透過詢問投資建議來測試記憶檢索和個人化回應功能。

**驗收情境**:

1. **Given** 使用者已儲存「科技股」偏好, **When** 詢問「幫我看看近期有潛力的股票」, **Then** 系統檢索記憶並推薦科技類股票
2. **Given** 使用者已儲存風險屬性為「中等」, **When** 請求投資建議, **Then** 系統提供符合中等風險的投資選項
3. **Given** 使用者有多項偏好記憶, **When** 尋求綜合建議, **Then** 系統整合所有相關偏好提供個人化建議

---

### 使用者故事 3 - 記憶回顧與更新 (優先級: P3)

使用者能查看系統已記住的投資偏好，並可更新或修正這些資訊。

**為何為此優先級**: 提供透明度和控制權，讓使用者了解和管理自己的偏好資料。

**獨立測試**: 可透過查看記憶摘要和嘗試更新偏好來獨立測試此功能。

**驗收情境**:

1. **Given** 使用者已建立多項記憶, **When** 請求「顯示我的投資偏好」, **Then** 系統列出已儲存的偏好摘要
2. **Given** 使用者想修改偏好, **When** 說「我現在偏好穩健型投資」, **Then** 系統更新風險偏好記憶
3. **Given** 使用者表達相衝突的偏好, **When** 新偏好與舊記憶矛盾, **Then** 系統詢問是否要更新並處理衝突

---

### 邊界情況

- 當使用者輸入模糊或無法歸類的投資偏好時，系統應儲存原始文本但標記為「未分類」
- 當瀏覽器 localStorage 達到儲存限制時，系統應停止儲存新記憶並通知使用者，用戶可手動清除舊記憶
- 當使用者輸入非投資相關內容時，系統不應自動儲存，但可選擇性地詢問是否要儲存
- 當記憶檢索失敗或回傳空結果時，系統應提供通用投資教育內容作為預設回應
- 當使用者首次訪問時，系統應在 localStorage 中自動生成 UUID 並使用該識別碼
- 當使用者清除瀏覽器 localStorage 時，所有記憶資料將被清除，下次訪問時將生成新的 UUID

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系統必須能夠從自然語言對話中自動識別和擷取投資偏好資訊
- **FR-002**: 系統必須將擷取的偏好資訊儲存到 Mem0 記憶庫中
- **FR-003**: 使用者必須能夠在無需登入的情況下直接開始對話
- **FR-004**: 系統必須能夠從 Mem0 記憶庫中檢索相關的歷史偏好資訊（最新 N 條記憶）
- **FR-005**: 系統必須將檢索到的記憶資訊整合到回應中，提供個人化建議
- **FR-006**: 系統必須使用本地 UUID 作為臨時識別碼區分不同使用者，並將其儲存在瀏覽器 localStorage 中
- **FR-007**: 系統必須能夠處理偏好資訊的更新和修正
- **FR-011**: 系統必須將所有臨時記憶資料無限期保留在 localStorage 中，直到瀏覽器儲存限制達到
- **FR-008**: 系統必須提供查看已儲存偏好的功能
- **FR-009**: 所有對話介面和回應必須使用繁體中文
- **FR-010**: 系統必須在記憶操作失敗時提供適當的錯誤處理
- **FR-012**: 系統必須透過 Google Gemini 2.5 Flash 進行對話和回應生成
- **FR-013**: 系統必須使用 Google Embeddings (gemini-embedding-001) 將記憶進行向量化處理
- **FR-014**: 系統必須使用 Chroma 向量資料庫進行語義相似性搜索
- **FR-015**: 系統必須使用 SQLite 儲存短期對話歷史和中繼資料
- **FR-016**: 系統必須實作 SQLite 中的延遲 TTL 過期機制清理過期記憶
- **FR-017**: 系統必須實作自動摘要壓縮功能以優化儲存空間

### 關鍵實體 *(包含資料相關功能)*

- **使用者偏好記憶**: 包含投資類型偏好、風險屬性、投資地區、投資時間軸等屬性
- **對話會話**: 代表單次對話實例，與臨時使用者識別碼關聯
- **記憶片段**: Mem0 中儲存的單一偏好或資訊項目，包含內容、時間戳記和相關性評分

## 成功標準 *(必填)*

### 可衡量結果

- **SC-001**: 使用者能在 30 秒內開始對話並成功儲存第一個投資偏好
- **SC-002**: 系統在 2 秒內完成記憶檢索並提供個人化回應
- **SC-003**: 90% 的投資偏好語句能被正確識別和分類儲存
- **SC-004**: 使用者能在 3 步內查看完整的偏好記憶摘要
- **SC-005**: 記憶檢索準確率達到 85% 以上（檢索到的資訊與查詢相關）
- **SC-006**: 系統支援同時處理 50 個並發對話會話而不影響效能

## 技術假設與約束

### 技術假設
- Google Gemini API 和 Embeddings API 可正常使用
- 瀏覽器支援 localStorage（現代 Chrome、Firefox、Safari、Edge）
- Chroma 向量資料庫可在本地無持久化存儲中執行
- SQLite 可在應用部署環境中執行

### 設計約束
- **無雲端同步**: 記憶資料完全本地儲存，不同裝置不共享
- **無使用者帳戶系統**: 依賴瀏覽器 localStorage 的臨時識別
- **無實時交易資料**: 所有股票建議僅基於記憶的投資偏好，不涉及實時報價
- **無訊息佇列**: 所有操作同步執行，無背景工作

## 澄清事項

### 會話 2025-10-30

- Q1: 臨時使用者識別碼應如何產生和儲存？→ A: 本地 UUID，使用瀏覽器 localStorage 儲存
- Q2: 系統應如何決定在回應中包含哪些記憶資訊？→ A: 最新 N 條記憶（無需考慮相關性）
- Q3: 臨時記憶資料應保留多長時間？→ A: 無限保留，直到瀏覽器 localStorage 達到限制

## 技術架構決策

### 後端框架與核心技術
- **後端框架**: FastAPI + Python 3.12
- **主要 LLM 提供商**: Google Gemini 2.5 Flash
- **嵌入模型**: Google Embeddings (gemini-embedding-001)
- **向量資料庫**: Chroma（本地執行）
- **短期記憶**: SQLite（包含延遲 TTL 過期和自動摘要壓縮）
- **測試工具**: VS Code REST Client

### 核心實踐目標
本專案著重於以下三個實踐領域：

1. **語義記憶捕捉**: 從使用者輸入中擷取並轉換為 Mem0 語義記憶
2. **記憶檢索與注入**: 使用 Google Embeddings 和 Chroma 檢索並注入相關記憶
3. **上下文改進效果**: 展示持久語義上下文如何改進 LLM 回應質量

### 明確不使用的技術
- ❌ Redis、Kafka、Celery（無非同步工作佇列）
- ❌ AutoMapper 類工具（手動對應）
- ❌ Minimal APIs（完整 FastAPI 框架）
- ❌ 券商、交易或即時報價服務（純教育用途）

### 架構簡化說明
此設計優先考慮學習效果和實作清晰度，避免分散注意力的複雜性。使用 Chroma 本地儲存和 SQLite 便於快速迭代，Google Gemini 和 Embeddings API 消除本地模型部署的複雜性。
